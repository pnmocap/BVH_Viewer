BVH 网球动作分析功能开发文档
1. 项目概述
在现有的 Python BVH 3D 可视化工具基础上，集成一个“网球动作分析模块”。该模块旨在分析击球动作中关键发力部位（腰、胸、大臂、小臂、手）的角速度变化，以验证动力链（Kinetic Chain）的传递效率。
2. 开发环境与依赖
2.1 基础环境

Python版本: 3.8+


现有依赖: pygame, PyOpenGL, numpy

2.2 新增依赖
需要在终端运行以下命令安装绘图库：
pip install matplotlib

3. 核心算法设计
3.1 分析对象 (Target Joints)
根据您提供的 BVH 文件结构，确定的分析映射关系如下：

Waist (腰): 对应 BVH 节点 Spine


Chest (胸): 对应 BVH 节点 Spine2


Upper Arm (大臂): 对应 BVH 节点 RightArm (自适应支持左手)


Forearm (小臂): 对应 BVH 节点 RightForeArm (自适应支持左手)


Hand (手腕): 对应 BVH 节点 RightHand (自适应支持左手)

3.2 计算公式
采用角速度模值来反映总发力强度：

欧拉角差分: $\Delta \theta = \theta_{t} - \theta_{t-1}$


周期性修正: 处理欧拉角越界（如 $179^\circ \to -179^\circ$ 实际变化为 $2^\circ$）：


If $\Delta \theta > 180$, then $\Delta \theta \leftarrow \Delta \theta - 360$


If $\Delta \theta < -180$, then $\Delta \theta \leftarrow \Delta \theta + 360$


模值计算:


$$\omega = \frac{\sqrt{\Delta x^2 + \Delta y^2 + \Delta z^2}}{\Delta t}$$

4. 详细实现步骤
步骤 1: 引入必要的库
位置: 脚本最顶部 import 区域。

import matplotlib.pyplot as plt
import json
from datetime import datetime
# 原有的 imports 保持不变...
import pygame
# ...

步骤 2: 添加分析器类 (核心逻辑)
位置: 将此代码粘贴在 class OverlayManager (约第51行) 之前。
# ======================== 网球动作分析模块 ========================
class TennisAnalyzer:
    HISTORY_FILE = "tennis_analysis_history.json"

    @staticmethod
    def calculate_angular_velocities(joints, motion_data, frame_time):
        """
        计算指定关节的角速度模值 (单位: 度/秒)
        算法：sqrt(dx^2 + dy^2 + dz^2) / dt
        """
        # 定义关键部位映射
        target_joints = {
            'Waist (Spine)': 'Spine',
            'Chest (Spine2)': 'Spine2',
            'Upper Arm': 'RightArm',
            'Forearm': 'RightForeArm',
            'Hand': 'RightHand'
        }

        num_frames = len(motion_data)
        velocities = {k: [] for k in target_joints.keys()}
        
        # 1. 获取关节的通道索引
        joint_indices = {}
        for label, name in target_joints.items():
            final_name = name
            if name not in joints:
                # 自动适配左右手 (如果找不到RightArm就找LeftArm)
                alt_name = name.replace("Right", "Left") if "Right" in name else name.replace("Left", "Right")
                if alt_name in joints:
                    final_name = alt_name
                    print(f"[Analysis] Auto-switched {name} to {final_name}")
                else:
                    print(f"[Analysis] Warning: Joint {name} not found.")
                    continue
            
            joint_indices[label] = joints[final_name].channel_indices

        # 2. 逐帧计算
        for i in range(1, num_frames):
            for label, indices in joint_indices.items():
                if not indices: continue
                
                # 获取XYZ三轴的旋转差值
                diffs = []
                # BVH通常包含 Xrotation, Yrotation, Zrotation
                for channel_name in ['Xrotation', 'Yrotation', 'Zrotation']:
                    if channel_name in indices:
                        idx = indices[channel_name]
                        curr = motion_data[i][idx]
                        prev = motion_data[i-1][idx]
                        
                        d = curr - prev
                        
                        # 修正欧拉角跳变 (Wrap-around fix)
                        if d > 180: d -= 360
                        elif d < -180: d += 360
                        
                        diffs.append(d)
                    else:
                        diffs.append(0.0)

                # 计算模值 (Magnitude)
                sum_sq = sum([d**2 for d in diffs])
                magnitude = math.sqrt(sum_sq) / frame_time
                velocities[label].append(magnitude)

        return velocities

    @staticmethod
    def save_analysis(velocities, filename="Current_Session"):
        """保存当前分析结果到 JSON"""
        data_entry = {
            "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "filename": filename,
            "data": velocities
        }
        
        history = []
        if os.path.exists(TennisAnalyzer.HISTORY_FILE):
            try:
                with open(TennisAnalyzer.HISTORY_FILE, 'r') as f:
                    history = json.load(f)
            except: pass
        
        # 追加新记录并保留最近 5 条
        history.append(data_entry)
        if len(history) > 5:
            history = history[-5:]
            
        with open(TennisAnalyzer.HISTORY_FILE, 'w') as f:
            json.dump(history, f)
        
        return history

    @staticmethod
    def show_plot(history_data):
        """绘制多组数据对比图"""
        if not history_data: return

        plt.figure(figsize=(12, 8))
        
        # 颜色配置
        colors = {
            'Waist (Spine)': '#FF9900',  # 橙色
            'Chest (Spine2)': '#33CC33', # 绿色
            'Upper Arm': '#3366FF',      # 蓝色
            'Forearm': '#00CCCC',        # 青色
            'Hand': '#CC0000'            # 红色
        }
        
        latest_entry = history_data[-1]
        history_entries = history_data[:-1]
        
        # --- 1. 绘制历史数据的 Hand 曲线作为背景参考 (虚线) ---
        for entry in history_entries:
            if 'Hand' in entry['data']:
                vals = entry['data']['Hand']
                frames = range(1, len(vals) + 1)
                plt.plot(frames, vals, linestyle=':', color='gray', alpha=0.5, 
                         label=f"History: Hand ({entry['filename']})")

        # --- 2. 绘制当前数据的 5 个部位 (实线) ---
        current_data = latest_entry['data']
        # 假设所有部位帧数一致，取第一个非空的长度
        first_key = next(iter(current_data))
        frames = range(1, len(current_data[first_key]) + 1)

        for part, values in current_data.items():
            if not values: continue
            
            # 找峰值
            max_val = max(values)
            max_frame = values.index(max_val) + 1
            
            line_color = colors.get(part, 'black')
            
            # 绘图
            plt.plot(frames, values, label=f"{part}", color=line_color, linewidth=2)
            
            # 标记峰值点
            plt.plot(max_frame, max_val, 'o', color=line_color)
            # 添加文本标注
            plt.annotate(
                f'{int(max_val)}°/s\nFrame {max_frame}', 
                xy=(max_frame, max_val), 
                xytext=(0, 10), 
                textcoords='offset points', 
                ha='center', 
                fontsize=8,
                bbox=dict(boxstyle="round,pad=0.3", fc="white", ec=line_color, alpha=0.8)
            )

        plt.title(f"Tennis Stroke Kinetic Chain Analysis\nFile: {latest_entry['filename']}")
        plt.xlabel("Frame Index")
        plt.ylabel("Angular Velocity Magnitude (deg/s)")
        plt.legend(loc='upper right')
        plt.grid(True, linestyle='--', alpha=0.7)
        plt.tight_layout()
        plt.show()
# ======================== 模块结束 ========================


步骤 3: 在主函数中定义按钮区域
位置: main() 函数内部，定义 export_bvh_btn_rect 的下方（约第1267行附近）。
# ... 原有代码 ...
    export_bvh_btn_rect = pygame.Rect(
        calibrate_btn_rect.x + calibrate_btn_rect.width + 10,
        btn_y, 100, btn_height
    ) 

    # === 新增：定义网球分析按钮区域 ===
    tennis_btn_rect = pygame.Rect(
        export_bvh_btn_rect.x + export_bvh_btn_rect.width + 10,
        btn_y, 110, btn_height
    )

步骤 4: 渲染分析按钮
位置: main() 函数的 while running: 循环内，在调用 draw_realtime_ui 之后（约第1758行附近）。我们需要手动绘制这个按钮。
# ... 原有代码: draw_realtime_ui(...) ...

        # === 新增：绘制网球分析按钮 ===
        # 切换到 2D 投影模式
        glMatrixMode(GL_PROJECTION); glPushMatrix(); glLoadIdentity()
        glOrtho(0, display[0], 0, display[1], -1, 1)
        glMatrixMode(GL_MODELVIEW); glPushMatrix(); glLoadIdentity()
        glDisable(GL_DEPTH_TEST)

        # 绘制按钮背景 (淡黄色 #EEDD82)
        tx, ty = tennis_btn_rect.x, display[1] - tennis_btn_rect.y - tennis_btn_rect.height
        draw_rectangle(tx, ty, tennis_btn_rect.width, tennis_btn_rect.height, (0.93, 0.87, 0.51))
        
        # 绘制按钮边框 (黑色)
        glColor3f(0, 0, 0); glLineWidth(1.0)
        glBegin(GL_LINE_LOOP)
        glVertex2f(tx, ty); glVertex2f(tx + tennis_btn_rect.width, ty)
        glVertex2f(tx + tennis_btn_rect.width, ty + tennis_btn_rect.height); glVertex2f(tx, ty + tennis_btn_rect.height)
        glEnd()

        # 绘制按钮文字
        # 简单的居中计算
        t_label = "Tennis Analyze"
        label_x = tx + (tennis_btn_rect.width - len(t_label)*7) / 2  # 估算宽度
        label_y = ty + (tennis_btn_rect.height - 12) / 2 + 2         # 垂直居中微调
        draw_text_2d(label_x, label_y, t_label, (0, 0, 0), 12)

        # 恢复 3D 状态
        glEnable(GL_DEPTH_TEST)
        glMatrixMode(GL_PROJECTION); glPopMatrix()
        glMatrixMode(GL_MODELVIEW); glPopMatrix()
        # =================================
步骤 5: 绑定按钮点击事件
位置: main() 函数的事件循环中，if event.type == pygame.MOUSEBUTTONDOWN: 下方（约第1566行附近）。
# ... 原有代码: elif export_bvh_btn_rect.collidepoint(event.pos): ...
                
                # === 新增：点击网球分析按钮 ===
                elif tennis_btn_rect.collidepoint(event.pos):
                    if frames > 0:
                        print("[System] Starting Tennis Analysis...")
                        # 1. 计算角速度
                        velocities = TennisAnalyzer.calculate_angular_velocities(joints, motion_data, frame_time)
                        
                        # 2. 获取文件名用于记录
                        # 尝试从 parse_bvh 上下文获取，如果没有则默认
                        try:
                            # 注意：如果您的代码中没有全局保存 file_path，这里可能显示为 Unknown
                            # 建议在 load_file_dialog 中增加 global file_path 并在加载时赋值
                            current_fname = os.path.basename(file_path) 
                        except:
                            current_fname = "Session_Data"
                            
                        # 3. 保存并获取历史数据
                        history = TennisAnalyzer.save_analysis(velocities, current_fname)
                        
                        # 4. 弹出图表
                        TennisAnalyzer.show_plot(history)
                    else:
                        print("[System] Error: Please load a BVH file first.")
5. 预期效果验证
完成上述开发后，您可以按照以下流程验证功能：

启动程序: 运行脚本，界面右上角应出现淡黄色的 "Tennis Analyze" 按钮。


加载数据: 点击 "Load File" 加载您提供的网球 BVH 文件。


执行分析: 点击 "Tennis Analyze" 按钮。


查看结果:


控制台: 输出 [System] Starting Tennis Analysis...。


图表窗口: 弹出一个 Matplotlib 窗口。


曲线: 应包含 5 条不同颜色的实线（腰、胸、大臂、小臂、手）。


峰值: 每条曲线的最高点应有圆点标记，并显示类似 450°/s Frame 120 的标签。


发力顺序: 观察峰值出现的先后顺序，理想的正手击球顺序应为 腰/胸 -> 臂 -> 手。


历史对比: 关闭图表，加载另一个 BVH 文件，再次点击分析。新图表中应包含上一次的 "Hand" 曲线（灰色虚线）作为背景对比。

