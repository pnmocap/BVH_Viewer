================================================================================
       BVH Viewer + MocapAPI SDK 集成开发文档
       实时动捕数据可视化与录制导出系统
================================================================================

版本：1.0
日期：2025年12月
项目路径：d:\Noitom\BVH_Viewer

================================================================================
                              目 录
================================================================================
一、项目概述
二、技术架构设计
三、SDK集成方案
四、核心功能模块设计
五、数据结构与接口定义
六、详细实现方案
七、UI界面扩展设计
八、开发计划与里程碑
九、附录

================================================================================
                         一、项目概述
================================================================================

1.1 项目背景
--------------------------------------------------------------------------------
当前 BVH Viewer 是一个基于 Pygame + OpenGL 开发的 BVH 3D 可视化与分析工具，
核心功能仅限于：
  - 导入本地 BVH 文件进行可视化展示
  - 运动学数据计算（位置、速度、加速度、解剖学角度）
  - 数据导出为 CSV 格式

现需集成诺亦腾公司的 MocapAPI SDK，使其支持：
  - 实时连接 PN-Link 动捕设备
  - 实时展示动捕数据的 3D 骨骼动画
  - 动作数据录制功能
  - 导出录制数据为 BVH 格式文件

1.2 项目目标
--------------------------------------------------------------------------------
【主要目标】
  1. 实时动画展示：通过 MocapAPI 连接 PN-Link 设备，实时接收并渲染骨骼动画
  2. 数据录制功能：支持录制实时动捕数据，存储为可回放的格式
  3. BVH 导出功能：将录制的数据导出为标准 BVH 文件格式

【次要目标】
  1. 模式切换：支持"离线模式"（加载BVH文件）和"实时模式"（连接设备）
  2. 设备连接管理：支持配置网络参数、连接状态监控
  3. 校准功能集成：支持设备校准操作

1.3 功能需求矩阵
--------------------------------------------------------------------------------
┌─────────────────┬─────────────────────────────────────────┬──────────┐
│   功能模块      │              功能描述                    │   优先级 │
├─────────────────┼─────────────────────────────────────────┼──────────┤
│ 设备连接        │ 配置IP/端口，建立与PN-Link的UDP连接      │   P0     │
│ 实时数据接收    │ 轮询MocapAPI事件，获取Avatar关节数据     │   P0     │
│ 实时3D渲染      │ 将实时数据转换为骨骼矩阵并渲染           │   P0     │
│ 数据录制        │ 按帧存储实时关节数据到内存缓冲区         │   P0     │
│ 录制回放        │ 播放已录制的数据                        │   P1     │
│ BVH导出         │ 将录制数据导出为标准BVH文件              │   P0     │
│ 设备校准        │ 集成动作校准命令                        │   P1     │
│ 模式切换UI      │ 离线/实时模式切换界面                   │   P0     │
│ 连接状态显示    │ 显示设备连接状态、数据帧率等            │   P1     │
│ 快捷键支持      │ 录制开始/停止、连接/断开等快捷操作      │   P2     │
└─────────────────┴─────────────────────────────────────────┴──────────┘

================================================================================
                         二、技术架构设计
================================================================================

2.1 系统架构图
--------------------------------------------------------------------------------

   ┌──────────────────────────────────────────────────────────────────────┐
   │                         BVH Viewer Pro                               │
   │  ┌────────────────────────────────────────────────────────────────┐  │
   │  │                     UI Layer (Pygame + OpenGL)                  │  │
   │  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────────┐    │  │
   │  │  │ 3D View  │  │ Control  │  │ Timeline │  │  Data Panel  │    │  │
   │  │  │  Panel   │  │  Panel   │  │  Panel   │  │  (Pos/Vel)   │    │  │
   │  │  └──────────┘  └──────────┘  └──────────┘  └──────────────┘    │  │
   │  └────────────────────────────────────────────────────────────────┘  │
   │                              │                                        │
   │  ┌────────────────────────────────────────────────────────────────┐  │
   │  │                    Core Logic Layer                             │  │
   │  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────────────┐  │  │
   │  │  │ Mode Manager │  │ Data Manager │  │  Recording Manager   │  │  │
   │  │  │(离线/实时)   │  │ (数据转换)   │  │  (录制/回放/导出)    │  │  │
   │  │  └──────────────┘  └──────────────┘  └──────────────────────┘  │  │
   │  └────────────────────────────────────────────────────────────────┘  │
   │                              │                                        │
   │  ┌────────────────────────────────────────────────────────────────┐  │
   │  │                    Data Source Layer                            │  │
   │  │  ┌─────────────────────┐      ┌─────────────────────────────┐  │  │
   │  │  │   BVH File Parser   │      │    MocapAPI Connector       │  │  │
   │  │  │   (原有功能)         │      │   (新增SDK集成)            │  │  │
   │  │  └─────────────────────┘      └─────────────────────────────┘  │  │
   │  └────────────────────────────────────────────────────────────────┘  │
   │                              │                                        │
   │                    ┌─────────┴─────────┐                              │
   │                    │                   │                              │
   │             ┌──────▼──────┐    ┌───────▼───────┐                      │
   │             │  BVH Files  │    │  PN-Link 设备 │                      │
   │             │  (*.bvh)    │    │  (UDP 网络)   │                      │
   │             └─────────────┘    └───────────────┘                      │
   └──────────────────────────────────────────────────────────────────────┘

2.2 核心类设计
--------------------------------------------------------------------------------

【新增核心类】

1. MocapConnector (MocapAPI连接管理器)
   - 职责：管理与PN-Link设备的连接、事件轮询、数据获取
   - 关键属性：
     * app: MCPApplication 实例
     * settings: MCPSettings 配置
     * is_connected: 连接状态
     * is_capturing: 采集状态
   - 关键方法：
     * connect(ip, port) -> bool
     * disconnect() -> void
     * start_capture() -> bool
     * stop_capture() -> bool
     * poll_events() -> list[MCPEvent]
     * get_avatar_data(avatar_handle) -> dict

2. RecordingManager (录制管理器)
   - 职责：管理数据录制、回放、BVH导出
   - 关键属性：
     * recorded_frames: list[FrameData]
     * is_recording: 录制状态
     * record_start_time: 录制开始时间
     * frame_time: 帧间隔
   - 关键方法：
     * start_recording(frame_time) -> void
     * stop_recording() -> int (返回总帧数)
     * record_frame(joints_data) -> void
     * export_to_bvh(file_path) -> bool
     * get_recorded_frame(index) -> FrameData

3. ModeManager (模式管理器)
   - 职责：管理离线/实时模式切换
   - 关键属性：
     * current_mode: "offline" | "realtime"
     * data_source: BVHParser | MocapConnector
   - 关键方法：
     * switch_to_offline() -> void
     * switch_to_realtime() -> void
     * get_current_frame_data() -> dict

2.3 数据流设计
--------------------------------------------------------------------------------

【实时模式数据流】

  PN-Link设备 ──UDP──► MocapAPI ──事件──► MocapConnector
                                              │
                                              ▼
                               ┌──────────────────────────┐
                               │   Avatar/Joint数据解析    │
                               │   - 关节名称              │
                               │   - 位置 (x, y, z)        │
                               │   - 旋转 (w, x, y, z)     │
                               └──────────────────────────┘
                                              │
                       ┌──────────────────────┼──────────────────────┐
                       ▼                      ▼                      ▼
               ┌──────────────┐      ┌──────────────┐      ┌──────────────┐
               │  3D渲染引擎  │      │  录制管理器  │      │  数据面板    │
               │  (OpenGL)    │      │  (可选)      │      │  (UI显示)    │
               └──────────────┘      └──────────────┘      └──────────────┘

【录制与BVH导出数据流】

  实时数据帧 ───► RecordingManager.record_frame()
                              │
                              ▼
                  ┌──────────────────────┐
                  │   recorded_frames    │
                  │   (内存帧缓冲区)     │
                  └──────────────────────┘
                              │
                   用户点击"导出BVH"
                              │
                              ▼
                  ┌──────────────────────┐
                  │  BVHExporter.export  │
                  │  - 生成HIERARCHY     │
                  │  - 生成MOTION数据    │
                  └──────────────────────┘
                              │
                              ▼
                       ┌──────────┐
                       │ .bvh文件 │
                       └──────────┘

================================================================================
                         三、SDK集成方案
================================================================================

3.1 SDK文件集成
--------------------------------------------------------------------------------

【需拷贝的SDK文件】

源目录: c:\Users\Leo\Desktop\mocapapi_python\

├── mocap_api.py          # MocapAPI核心接口封装 (必需)
└── lib\
    └── MocapApi.dll      # Windows平台动态库 (必需)

目标目录: d:\Noitom\BVH_Viewer\

├── mocap_api.py          # 拷贝至项目根目录
└── lib\
    └── MocapApi.dll      # 创建lib目录并拷贝

【修改mocap_api.py的库路径加载】

由于工作目录可能不同，建议修改mocap_api.py第18-22行：

```python
# 原代码
MocapApi = cdll.LoadLibrary(os.path.join(os.path.dirname(__file__), {
  'DarWin': '',
  'Linux':  so_files_path,
  'Windows': './lib/MocapApi.dll'
}[system()]))

# 修改为 (确保使用绝对路径)
_lib_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'lib', 'MocapApi.dll')
MocapApi = cdll.LoadLibrary(_lib_path)
```

3.2 网络配置要求
--------------------------------------------------------------------------------

【PN-Link设备默认配置】
  - 设备IP: 10.42.0.202
  - 监听端口: 8080 (UDP)

【上位机(本机)配置要求】
  - 本机IP需设置为同网段，例如: 10.42.0.101
  - 本机接收端口: 8002 (可配置)

【代码配置示例】
```python
settings = MCPSettings()
settings.set_bvh_data(MCPBvhData.Binary)
settings.set_bvh_transformation(MCPBvhDisplacement.Enable)
settings.set_bvh_rotation(MCPBvhRotation.YXZ)  # 旋转顺序
settings.SetSettingsUDPEx('10.42.0.101', 8002)  # 本机IP和端口
settings.SetSettingsUDPServer('10.42.0.202', 8080)  # 设备IP和端口
```

3.3 核心API使用说明
--------------------------------------------------------------------------------

【1. 创建应用并连接】
```python
from mocap_api import *

app = MCPApplication()
settings = MCPSettings()

# 配置设置
settings.set_bvh_data(MCPBvhData.Binary)
settings.set_bvh_transformation(MCPBvhDisplacement.Enable)
settings.set_bvh_rotation(MCPBvhRotation.YXZ)
settings.SetSettingsUDPEx(local_ip, local_port)
settings.SetSettingsUDPServer(device_ip, device_port)

app.set_settings(settings)
success, msg = app.open()  # 打开连接
```

【2. 发送采集命令】
```python
app.queue_command(EMCPCommand.CommandStartCapture)  # 开始采集
app.queue_command(EMCPCommand.CommandStopCapture)   # 停止采集
app.queue_command(EMCPCommand.CommandCalibrateMotion)  # 校准
```

【3. 轮询事件获取数据】
```python
events = app.poll_next_event()
for evt in events:
    if evt.event_type == MCPEventType.AvatarUpdated:
        avatar = MCPAvatar(evt.event_data.avatar_handle)
        joints = avatar.get_joints()
        for joint in joints:
            name = joint.get_name()           # 关节名称
            pos = joint.get_local_position()  # (x, y, z) 位置
            rot = joint.get_local_rotation()  # (w, x, y, z) 四元数
```

【4. 关节数据结构】
```
MCPJointTag 定义的关节顺序 (共59个关节 + 1个计数):
  Hips(0), RightUpLeg(1), RightLeg(2), RightFoot(3),
  LeftUpLeg(4), LeftLeg(5), LeftFoot(6),
  Spine(7), Spine1(8), Spine2(9),
  Neck(10), Neck1(11), Head(12),
  RightShoulder(13), RightArm(14), RightForeArm(15), RightHand(16),
  RightHandThumb1-3(17-19), RightInHandIndex(20), RightHandIndex1-3(21-23),
  ... (完整手指关节)
  LeftShoulder(36), LeftArm(37), LeftForeArm(38), LeftHand(39),
  ... (左手手指关节)
  Spine3(59)
```

================================================================================
                         四、核心功能模块设计
================================================================================

4.1 MocapConnector 模块 (新增文件: mocap_connector.py)
--------------------------------------------------------------------------------

```python
"""
MocapAPI连接管理器
负责与PN-Link设备的通信和数据获取
"""
import threading
import time
from mocap_api import *

class MocapConnector:
    def __init__(self):
        self.app = None
        self.settings = None
        self.is_connected = False
        self.is_capturing = False
        self.current_command = -1
        self.latest_frame_data = None
        self._lock = threading.Lock()
        
        # 默认网络配置
        self.local_ip = '10.42.0.101'
        self.local_port = 8002
        self.device_ip = '10.42.0.202'
        self.device_port = 8080
    
    def configure(self, local_ip, local_port, device_ip, device_port):
        """配置网络参数"""
        self.local_ip = local_ip
        self.local_port = local_port
        self.device_ip = device_ip
        self.device_port = device_port
    
    def connect(self) -> tuple[bool, str]:
        """建立与设备的连接"""
        try:
            self.app = MCPApplication()
            self.settings = MCPSettings()
            
            self.settings.set_bvh_data(MCPBvhData.Binary)
            self.settings.set_bvh_transformation(MCPBvhDisplacement.Enable)
            self.settings.set_bvh_rotation(MCPBvhRotation.YXZ)
            self.settings.SetSettingsUDPEx(self.local_ip, self.local_port)
            self.settings.SetSettingsUDPServer(self.device_ip, self.device_port)
            
            self.app.set_settings(self.settings)
            success, msg = self.app.open()
            self.is_connected = success
            return success, msg
        except Exception as e:
            return False, str(e)
    
    def disconnect(self):
        """断开连接"""
        if self.app:
            self.app.close()
            self.is_connected = False
            self.is_capturing = False
    
    def start_capture(self) -> bool:
        """开始采集"""
        if not self.is_connected:
            return False
        self.app.queue_command(EMCPCommand.CommandStartCapture)
        self.current_command = EMCPCommand.CommandStartCapture
        return True
    
    def stop_capture(self) -> bool:
        """停止采集"""
        if not self.is_connected:
            return False
        self.app.queue_command(EMCPCommand.CommandStopCapture)
        self.current_command = EMCPCommand.CommandStopCapture
        return True
    
    def calibrate(self) -> bool:
        """开始校准"""
        if not self.is_capturing:
            return False
        self.app.queue_command(EMCPCommand.CommandCalibrateMotion)
        return True
    
    def poll_and_update(self) -> dict:
        """
        轮询事件并更新数据
        返回最新的帧数据，格式为:
        {
            'joints': {
                'Hips': {'position': (x,y,z), 'rotation': (w,x,y,z)},
                'RightUpLeg': {...},
                ...
            },
            'timestamp': float
        }
        """
        if not self.is_connected:
            return None
        
        frame_data = None
        events = self.app.poll_next_event()
        
        for evt in events:
            if evt.event_type == MCPEventType.AvatarUpdated:
                self.is_capturing = True
                frame_data = self._parse_avatar(evt.event_data.avatar_handle)
                frame_data['timestamp'] = evt.timestamp
            elif evt.event_type == MCPEventType.CommandReply:
                if evt.event_data.commandRespond._replay == MCPReplay.MCPReplay_Result:
                    if self.current_command == EMCPCommand.CommandStopCapture:
                        self.is_capturing = False
                    self.current_command = -1
        
        if frame_data:
            with self._lock:
                self.latest_frame_data = frame_data
        
        return frame_data
    
    def _parse_avatar(self, avatar_handle) -> dict:
        """解析Avatar数据为字典格式"""
        avatar = MCPAvatar(avatar_handle)
        joints_data = {}
        
        for joint in avatar.get_joints():
            name = joint.get_name()
            pos = joint.get_local_position()  # (x, y, z)
            rot = joint.get_local_rotation()  # (w, x, y, z)
            
            joints_data[name] = {
                'position': pos if pos else (0.0, 0.0, 0.0),
                'rotation': rot if rot else (1.0, 0.0, 0.0, 0.0)
            }
        
        return {'joints': joints_data}
    
    def get_latest_frame(self) -> dict:
        """获取最新的帧数据（线程安全）"""
        with self._lock:
            return self.latest_frame_data
```

4.2 RecordingManager 模块 (新增文件: recording_manager.py)
--------------------------------------------------------------------------------

```python
"""
录制管理器
负责数据录制、回放和BVH导出
"""
import time
import numpy as np
from dataclasses import dataclass
from typing import List, Dict, Optional

@dataclass
class FrameData:
    """单帧数据结构"""
    frame_index: int
    timestamp: float
    joints: Dict[str, Dict]  # {name: {position, rotation}}

class RecordingManager:
    # 标准BVH骨骼层级定义
    HIERARCHY_TEMPLATE = '''HIERARCHY
ROOT Hips
{
    OFFSET 0.00 0.00 0.00
    CHANNELS 6 Xposition Yposition Zposition Zrotation Xrotation Yrotation
    JOINT RightUpLeg
    {
        OFFSET -8.50 0.00 0.00
        CHANNELS 3 Zrotation Xrotation Yrotation
        JOINT RightLeg
        {
            OFFSET 0.00 -40.00 0.00
            CHANNELS 3 Zrotation Xrotation Yrotation
            JOINT RightFoot
            {
                OFFSET 0.00 -40.00 0.00
                CHANNELS 3 Zrotation Xrotation Yrotation
                End Site
                {
                    OFFSET 0.00 -7.85 14.28
                }
            }
        }
    }
    JOINT LeftUpLeg
    {
        OFFSET 8.50 0.00 0.00
        CHANNELS 3 Zrotation Xrotation Yrotation
        JOINT LeftLeg
        {
            OFFSET 0.00 -40.00 0.00
            CHANNELS 3 Zrotation Xrotation Yrotation
            JOINT LeftFoot
            {
                OFFSET 0.00 -40.00 0.00
                CHANNELS 3 Zrotation Xrotation Yrotation
                End Site
                {
                    OFFSET 0.00 -7.85 14.28
                }
            }
        }
    }
    JOINT Spine
    {
        OFFSET 0.00 10.00 0.00
        CHANNELS 3 Zrotation Xrotation Yrotation
        JOINT Spine1
        {
            OFFSET 0.00 10.00 0.00
            CHANNELS 3 Zrotation Xrotation Yrotation
            JOINT Spine2
            {
                OFFSET 0.00 10.00 0.00
                CHANNELS 3 Zrotation Xrotation Yrotation
                JOINT Neck
                {
                    OFFSET 0.00 10.00 0.00
                    CHANNELS 3 Zrotation Xrotation Yrotation
                    JOINT Head
                    {
                        OFFSET 0.00 8.00 0.00
                        CHANNELS 3 Zrotation Xrotation Yrotation
                        End Site
                        {
                            OFFSET 0.00 16.45 0.00
                        }
                    }
                }
                JOINT RightShoulder
                {
                    OFFSET -5.00 8.00 0.00
                    CHANNELS 3 Zrotation Xrotation Yrotation
                    JOINT RightArm
                    {
                        OFFSET -12.00 0.00 0.00
                        CHANNELS 3 Zrotation Xrotation Yrotation
                        JOINT RightForeArm
                        {
                            OFFSET -25.00 0.00 0.00
                            CHANNELS 3 Zrotation Xrotation Yrotation
                            JOINT RightHand
                            {
                                OFFSET -25.00 0.00 0.00
                                CHANNELS 3 Zrotation Xrotation Yrotation
                                End Site
                                {
                                    OFFSET -8.00 0.00 0.00
                                }
                            }
                        }
                    }
                }
                JOINT LeftShoulder
                {
                    OFFSET 5.00 8.00 0.00
                    CHANNELS 3 Zrotation Xrotation Yrotation
                    JOINT LeftArm
                    {
                        OFFSET 12.00 0.00 0.00
                        CHANNELS 3 Zrotation Xrotation Yrotation
                        JOINT LeftForeArm
                        {
                            OFFSET 25.00 0.00 0.00
                            CHANNELS 3 Zrotation Xrotation Yrotation
                            JOINT LeftHand
                            {
                                OFFSET 25.00 0.00 0.00
                                CHANNELS 3 Zrotation Xrotation Yrotation
                                End Site
                                {
                                    OFFSET 8.00 0.00 0.00
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}'''

    # 简化版关节通道顺序（与HIERARCHY对应）
    JOINT_ORDER = [
        'Hips',  # 6 channels: pos + rot
        'RightUpLeg', 'RightLeg', 'RightFoot',
        'LeftUpLeg', 'LeftLeg', 'LeftFoot',
        'Spine', 'Spine1', 'Spine2',
        'Neck', 'Head',
        'RightShoulder', 'RightArm', 'RightForeArm', 'RightHand',
        'LeftShoulder', 'LeftArm', 'LeftForeArm', 'LeftHand'
    ]
    
    def __init__(self):
        self.recorded_frames: List[FrameData] = []
        self.is_recording = False
        self.record_start_time = 0.0
        self.frame_time = 1.0 / 60.0  # 默认60fps
        self._frame_counter = 0
    
    def start_recording(self, fps: float = 60.0):
        """开始录制"""
        self.recorded_frames.clear()
        self.is_recording = True
        self.record_start_time = time.time()
        self.frame_time = 1.0 / fps
        self._frame_counter = 0
        print(f"Recording started at {fps} FPS")
    
    def stop_recording(self) -> int:
        """停止录制，返回总帧数"""
        self.is_recording = False
        total_frames = len(self.recorded_frames)
        print(f"Recording stopped. Total frames: {total_frames}")
        return total_frames
    
    def record_frame(self, joints_data: Dict):
        """记录一帧数据"""
        if not self.is_recording:
            return
        
        frame = FrameData(
            frame_index=self._frame_counter,
            timestamp=time.time() - self.record_start_time,
            joints=joints_data.copy()
        )
        self.recorded_frames.append(frame)
        self._frame_counter += 1
    
    def get_frame_count(self) -> int:
        """获取已录制帧数"""
        return len(self.recorded_frames)
    
    def get_recorded_frame(self, index: int) -> Optional[FrameData]:
        """获取指定帧"""
        if 0 <= index < len(self.recorded_frames):
            return self.recorded_frames[index]
        return None
    
    def _quaternion_to_euler(self, w, x, y, z) -> tuple:
        """四元数转欧拉角 (ZXY顺序, 返回角度)"""
        import math
        
        # Roll (X-axis)
        sinr_cosp = 2 * (w * x + y * z)
        cosr_cosp = 1 - 2 * (x * x + y * y)
        roll = math.atan2(sinr_cosp, cosr_cosp)
        
        # Pitch (Y-axis)
        sinp = 2 * (w * y - z * x)
        if abs(sinp) >= 1:
            pitch = math.copysign(math.pi / 2, sinp)
        else:
            pitch = math.asin(sinp)
        
        # Yaw (Z-axis)
        siny_cosp = 2 * (w * z + x * y)
        cosy_cosp = 1 - 2 * (y * y + z * z)
        yaw = math.atan2(siny_cosp, cosy_cosp)
        
        # 转换为角度
        return (
            math.degrees(roll),
            math.degrees(pitch),
            math.degrees(yaw)
        )
    
    def export_to_bvh(self, file_path: str) -> bool:
        """导出为BVH文件"""
        if not self.recorded_frames:
            print("No frames to export")
            return False
        
        try:
            with open(file_path, 'w') as f:
                # 写入层级结构
                f.write(self.HIERARCHY_TEMPLATE)
                f.write('\n')
                
                # 写入运动数据头
                f.write('MOTION\n')
                f.write(f'Frames: {len(self.recorded_frames)}\n')
                f.write(f'Frame Time: {self.frame_time:.6f}\n')
                
                # 写入每帧数据
                for frame in self.recorded_frames:
                    frame_line = self._generate_frame_line(frame)
                    f.write(frame_line + '\n')
            
            print(f"BVH exported to: {file_path}")
            return True
        except Exception as e:
            print(f"Export failed: {e}")
            return False
    
    def _generate_frame_line(self, frame: FrameData) -> str:
        """生成单帧的BVH数据行"""
        values = []
        
        for joint_name in self.JOINT_ORDER:
            joint_data = frame.joints.get(joint_name, {})
            pos = joint_data.get('position', (0.0, 0.0, 0.0))
            rot = joint_data.get('rotation', (1.0, 0.0, 0.0, 0.0))
            
            # 四元数转欧拉角
            euler = self._quaternion_to_euler(rot[0], rot[1], rot[2], rot[3])
            
            if joint_name == 'Hips':
                # 根节点有位置通道
                values.extend([pos[0], pos[1], pos[2]])
            
            # 旋转通道 (ZXY顺序)
            values.extend([euler[2], euler[0], euler[1]])
        
        return ' '.join(f'{v:.6f}' for v in values)
    
    def clear(self):
        """清空录制数据"""
        self.recorded_frames.clear()
        self._frame_counter = 0
```

4.3 数据转换桥接模块
--------------------------------------------------------------------------------

将MocapAPI数据转换为BVH Viewer现有的Joint格式:

```python
def convert_mocap_to_viewer_format(mocap_frame_data: dict, joints: dict):
    """
    将MocapAPI的帧数据转换为BVH Viewer的Joint矩阵格式
    
    参数:
        mocap_frame_data: MocapConnector返回的帧数据
        joints: BVH Viewer的joints字典
    """
    import numpy as np
    
    for joint_name, joint_data in mocap_frame_data['joints'].items():
        if joint_name not in joints:
            continue
        
        joint = joints[joint_name]
        pos = joint_data['position']
        rot = joint_data['rotation']  # (w, x, y, z)
        
        # 构建4x4变换矩阵
        # 1. 四元数转旋转矩阵
        w, x, y, z = rot
        R = np.array([
            [1-2*y*y-2*z*z, 2*x*y-2*z*w, 2*x*z+2*y*w],
            [2*x*y+2*z*w, 1-2*x*x-2*z*z, 2*y*z-2*x*w],
            [2*x*z-2*y*w, 2*y*z+2*x*w, 1-2*x*x-2*y*y]
        ])
        
        # 2. 构建完整的4x4矩阵
        matrix = np.identity(4)
        matrix[:3, :3] = R
        matrix[:3, 3] = pos if pos else (0, 0, 0)
        
        joint.matrix = matrix
```

================================================================================
                         五、数据结构与接口定义
================================================================================

5.1 关节名称映射
--------------------------------------------------------------------------------

MocapAPI关节名称与BVH Viewer的CUSTOM_JOINT_ORDER完全兼容:

┌────────────────────┬────────────────────┬──────────────────┐
│  MocapAPI Joint    │  BVH Viewer Joint  │      说明        │
├────────────────────┼────────────────────┼──────────────────┤
│ Hips               │ Hips               │ 根关节/骨盆      │
│ RightUpLeg         │ RightUpLeg         │ 右大腿           │
│ RightLeg           │ RightLeg           │ 右小腿           │
│ RightFoot          │ RightFoot          │ 右脚             │
│ LeftUpLeg          │ LeftUpLeg          │ 左大腿           │
│ LeftLeg            │ LeftLeg            │ 左小腿           │
│ LeftFoot           │ LeftFoot           │ 左脚             │
│ Spine              │ Spine              │ 脊柱1            │
│ Spine1             │ Spine1             │ 脊柱2            │
│ Spine2             │ Spine2             │ 脊柱3            │
│ Neck               │ Neck               │ 颈部             │
│ Neck1              │ Neck1              │ 颈部1            │
│ Head               │ Head               │ 头部             │
│ RightShoulder      │ RightShoulder      │ 右肩             │
│ RightArm           │ RightArm           │ 右上臂           │
│ RightForeArm       │ RightForeArm       │ 右前臂           │
│ RightHand          │ RightHand          │ 右手             │
│ RightHandThumb1-3  │ RightHandThumb1-3  │ 右拇指           │
│ RightInHandIndex   │ RightinHandindex   │ 右食指根(注意拼写)│
│ ... (其他手指关节) │ ...                │                  │
│ LeftShoulder       │ LeftShoulder       │ 左肩             │
│ LeftArm            │ LeftArm            │ 左上臂           │
│ LeftForeArm        │ LeftForeArm        │ 左前臂           │
│ LeftHand           │ LeftHand           │ 左手             │
│ ... (左手手指)     │ ...                │                  │
│ Spine3             │ Spine3             │ 脊柱4            │
└────────────────────┴────────────────────┴──────────────────┘

注意: MocapAPI使用 "RightInHandIndex" (带大写I)
      BVH Viewer使用 "RightinHandindex" (带小写i)
      需要在数据转换时进行映射

5.2 帧数据格式定义
--------------------------------------------------------------------------------

【MocapAPI原始帧格式】
```python
{
    'joints': {
        'Hips': {
            'position': (x, y, z),     # 单位: cm
            'rotation': (w, x, y, z)   # 四元数
        },
        'RightUpLeg': {
            'position': (x, y, z),
            'rotation': (w, x, y, z)
        },
        # ... 其他关节
    },
    'timestamp': 12345.678  # 时间戳
}
```

【BVH Viewer内部帧格式】
```python
motion_data[frame_index] = [
    # 每帧是一个浮点数数组，包含所有通道值
    # 顺序由关节的channel_start_index决定
    pos_x, pos_y, pos_z,  # Hips位置
    rot_z, rot_x, rot_y,  # Hips旋转 (欧拉角，度)
    rot_z, rot_x, rot_y,  # RightUpLeg旋转
    # ... 其他关节
]
```

5.3 连接状态枚举
--------------------------------------------------------------------------------

```python
class ConnectionState:
    DISCONNECTED = 0      # 未连接
    CONNECTING = 1        # 连接中
    CONNECTED = 2         # 已连接
    CAPTURING = 3         # 采集中
    CALIBRATING = 4       # 校准中
    ERROR = -1            # 错误状态
```

5.4 应用模式枚举
--------------------------------------------------------------------------------

```python
class AppMode:
    OFFLINE = "offline"     # 离线模式 (加载BVH文件)
    REALTIME = "realtime"   # 实时模式 (连接设备)
```

================================================================================
                         六、详细实现方案
================================================================================

6.1 主程序修改方案 (bvh_visualizer_improved.py)
--------------------------------------------------------------------------------

【修改1: 添加导入和全局变量】

```python
# 在文件开头添加
from mocap_connector import MocapConnector
from recording_manager import RecordingManager

# 新增全局变量
class AppState:
    mode = "offline"  # "offline" | "realtime"
    mocap_connector = None
    recording_manager = None
    connection_state = 0
```

【修改2: 新增UI按钮】

在main()函数中，添加以下按钮定义:
```python
# 新增按钮 (在原有按钮之后)
mode_btn_rect = pygame.Rect(
    trajectory_btn_rect.x + trajectory_btn_rect.width + 10,
    btn_y, 100, btn_height
)  # 模式切换按钮

connect_btn_rect = pygame.Rect(
    mode_btn_rect.x + mode_btn_rect.width + 10,
    btn_y, 100, btn_height
)  # 连接/断开按钮

record_btn_rect = pygame.Rect(
    connect_btn_rect.x + connect_btn_rect.width + 10,
    btn_y, 100, btn_height
)  # 录制按钮

export_bvh_btn_rect = pygame.Rect(
    record_btn_rect.x + record_btn_rect.width + 10,
    btn_y, 100, btn_height
)  # 导出BVH按钮
```

【修改3: 实时数据更新逻辑】

在主循环的渲染部分，添加实时模式处理:
```python
# 在主循环中
if AppState.mode == "realtime" and AppState.mocap_connector:
    if AppState.mocap_connector.is_capturing:
        # 轮询获取最新数据
        frame_data = AppState.mocap_connector.poll_and_update()
        
        if frame_data:
            # 转换数据格式并更新骨骼
            convert_mocap_to_viewer_format(frame_data, joints)
            
            # 如果正在录制，记录这一帧
            if AppState.recording_manager.is_recording:
                AppState.recording_manager.record_frame(frame_data['joints'])
            
            # 渲染骨骼
            draw_custom_skeleton(joints)
elif AppState.mode == "offline" and root_joint and len(motion_data) > 0:
    # 原有的离线播放逻辑
    if is_playing:
        update_joint_matrices(root_joint, motion_data[current_frame], joints)
        current_frame = (current_frame + 1) % frames
    else:
        update_joint_matrices(root_joint, motion_data[current_frame], joints)
    draw_custom_skeleton(joints)
```

【修改4: 按钮点击事件处理】

```python
# 模式切换按钮
if mode_btn_rect.collidepoint(event.pos):
    if AppState.mode == "offline":
        AppState.mode = "realtime"
        # 初始化连接器和录制器
        if not AppState.mocap_connector:
            AppState.mocap_connector = MocapConnector()
        if not AppState.recording_manager:
            AppState.recording_manager = RecordingManager()
    else:
        AppState.mode = "offline"
        # 断开连接
        if AppState.mocap_connector and AppState.mocap_connector.is_connected:
            AppState.mocap_connector.disconnect()

# 连接按钮 (仅实时模式可用)
elif connect_btn_rect.collidepoint(event.pos) and AppState.mode == "realtime":
    if not AppState.mocap_connector.is_connected:
        success, msg = AppState.mocap_connector.connect()
        if success:
            AppState.mocap_connector.start_capture()
    else:
        AppState.mocap_connector.stop_capture()
        AppState.mocap_connector.disconnect()

# 录制按钮 (仅实时模式可用)
elif record_btn_rect.collidepoint(event.pos) and AppState.mode == "realtime":
    if AppState.mocap_connector.is_capturing:
        if not AppState.recording_manager.is_recording:
            AppState.recording_manager.start_recording(fps=60.0)
        else:
            AppState.recording_manager.stop_recording()

# 导出BVH按钮
elif export_bvh_btn_rect.collidepoint(event.pos):
    if AppState.recording_manager and AppState.recording_manager.get_frame_count() > 0:
        export_bvh_dialog()
```

【修改5: BVH导出对话框】

```python
def export_bvh_dialog():
    """导出BVH文件对话框"""
    root = tk.Tk()
    root.withdraw()
    file_path = filedialog.asksaveasfilename(
        defaultextension=".bvh",
        filetypes=[("BVH files", "*.bvh")],
        title="导出BVH文件"
    )
    root.destroy()
    
    if file_path and AppState.recording_manager:
        success = AppState.recording_manager.export_to_bvh(file_path)
        if success:
            print(f"BVH导出成功: {file_path}")
        else:
            print("BVH导出失败")
```

6.2 状态信息显示
--------------------------------------------------------------------------------

在UI中显示连接状态和录制状态:

```python
def draw_connection_status(display):
    """绘制连接状态信息"""
    if AppState.mode == "realtime":
        status_text = f"Mode: Realtime | "
        
        if AppState.mocap_connector:
            if AppState.mocap_connector.is_connected:
                if AppState.mocap_connector.is_capturing:
                    status_text += "Status: Capturing"
                else:
                    status_text += "Status: Connected"
            else:
                status_text += "Status: Disconnected"
        else:
            status_text += "Status: Not initialized"
        
        # 录制状态
        if AppState.recording_manager and AppState.recording_manager.is_recording:
            frame_count = AppState.recording_manager.get_frame_count()
            status_text += f" | Recording: {frame_count} frames"
    else:
        status_text = "Mode: Offline"
    
    draw_text_2d(10, 50, status_text, (0.0, 0.5, 0.0), font_size=12)
```

6.3 配置对话框 (可选扩展)
--------------------------------------------------------------------------------

```python
def open_connection_settings():
    """打开连接配置对话框"""
    settings_win = tk.Tk()
    settings_win.title("连接设置")
    settings_win.geometry("300x200")
    
    # 本机IP
    tk.Label(settings_win, text="本机IP:").grid(row=0, column=0, padx=10, pady=5)
    local_ip_entry = tk.Entry(settings_win)
    local_ip_entry.insert(0, "10.42.0.101")
    local_ip_entry.grid(row=0, column=1, padx=10, pady=5)
    
    # 本机端口
    tk.Label(settings_win, text="本机端口:").grid(row=1, column=0, padx=10, pady=5)
    local_port_entry = tk.Entry(settings_win)
    local_port_entry.insert(0, "8002")
    local_port_entry.grid(row=1, column=1, padx=10, pady=5)
    
    # 设备IP
    tk.Label(settings_win, text="设备IP:").grid(row=2, column=0, padx=10, pady=5)
    device_ip_entry = tk.Entry(settings_win)
    device_ip_entry.insert(0, "10.42.0.202")
    device_ip_entry.grid(row=2, column=1, padx=10, pady=5)
    
    # 设备端口
    tk.Label(settings_win, text="设备端口:").grid(row=3, column=0, padx=10, pady=5)
    device_port_entry = tk.Entry(settings_win)
    device_port_entry.insert(0, "8080")
    device_port_entry.grid(row=3, column=1, padx=10, pady=5)
    
    def apply_settings():
        if AppState.mocap_connector:
            AppState.mocap_connector.configure(
                local_ip_entry.get(),
                int(local_port_entry.get()),
                device_ip_entry.get(),
                int(device_port_entry.get())
            )
        settings_win.destroy()
    
    tk.Button(settings_win, text="确认", command=apply_settings).grid(
        row=4, column=0, columnspan=2, pady=10
    )
    
    settings_win.mainloop()
```

================================================================================
                         七、UI界面扩展设计
================================================================================

7.1 新增按钮布局
--------------------------------------------------------------------------------

顶部按钮栏扩展:

┌──────────────────────────────────────────────────────────────────────────┐
│ [Load File] [Export Data] [Trajectory] ║ [Mode:Offline] [Connect] [Rec] │
└──────────────────────────────────────────────────────────────────────────┘
     原有功能按钮                        │     新增实时模式按钮

7.2 按钮状态显示
--------------------------------------------------------------------------------

【Mode按钮】
- 离线模式: 显示 "Mode: Offline" (灰色背景)
- 实时模式: 显示 "Mode: Realtime" (蓝色背景)

【Connect按钮】(仅实时模式可见)
- 未连接: 显示 "Connect" (灰色背景)
- 已连接: 显示 "Disconnect" (绿色背景)
- 连接中: 显示 "Connecting..." (黄色背景)

【Record按钮】(仅实时模式且已连接可见)
- 未录制: 显示 "Record" (灰色背景)
- 录制中: 显示 "Stop Rec" (红色背景, 闪烁效果)

【Export BVH按钮】
- 有录制数据: 可点击 (正常颜色)
- 无数据: 置灰不可点击

7.3 状态信息栏
--------------------------------------------------------------------------------

底部信息栏扩展:

┌──────────────────────────────────────────────────────────────────────────┐
│ BVH Viewer: 60 FPS | Mode: Realtime | Status: Capturing | Rec: 1234帧   │
└──────────────────────────────────────────────────────────────────────────┘

7.4 快捷键支持
--------------------------------------------------------------------------------

新增快捷键:

┌──────────────────┬────────────────────────────────────────┐
│     快捷键        │                 功能                   │
├──────────────────┼────────────────────────────────────────┤
│     M            │ 切换 离线/实时 模式                     │
│     C            │ 连接/断开设备 (实时模式)                │
│     R            │ 开始/停止录制 (实时模式)                │
│     E            │ 导出BVH文件                            │
│     K            │ 开始校准 (实时模式)                     │
│     Space        │ 播放/暂停 (原有功能)                    │
│     左/右箭头    │ 逐帧切换 (原有功能)                     │
└──────────────────┴────────────────────────────────────────┘

================================================================================
                         八、开发计划与里程碑
================================================================================

8.1 阶段划分
--------------------------------------------------------------------------------

【阶段1: 基础集成】 预计工时: 2天
  □ 拷贝SDK文件到项目目录
  □ 创建mocap_connector.py模块
  □ 实现基本的连接和断开功能
  □ 验证能够接收Avatar数据

【阶段2: 实时渲染】 预计工时: 3天
  □ 实现MocapAPI数据到Viewer格式的转换
  □ 添加模式切换功能
  □ 实现实时骨骼渲染
  □ 添加模式切换和连接按钮UI

【阶段3: 录制功能】 预计工时: 2天
  □ 创建recording_manager.py模块
  □ 实现帧数据缓存逻辑
  □ 添加录制按钮和状态显示
  □ 实现录制回放功能

【阶段4: BVH导出】 预计工时: 2天
  □ 实现四元数到欧拉角转换
  □ 实现BVH文件格式生成
  □ 添加导出对话框
  □ 验证导出的BVH文件可被重新加载

【阶段5: 优化完善】 预计工时: 2天
  □ 添加网络配置对话框
  □ 添加快捷键支持
  □ 添加错误处理和日志
  □ 性能优化和测试

8.2 文件变更清单
--------------------------------------------------------------------------------

【新增文件】
  + mocap_connector.py      # MocapAPI连接管理器
  + recording_manager.py    # 录制管理器
  + mocap_api.py            # SDK接口 (从mocapapi_python拷贝)
  + lib/MocapApi.dll        # SDK动态库 (从mocapapi_python拷贝)

【修改文件】
  * bvh_visualizer_improved.py  # 主程序，添加实时模式支持
  * requirements.txt            # 添加新依赖 (如需要)

8.3 依赖更新
--------------------------------------------------------------------------------

requirements.txt 可能需要添加:
```
# 原有依赖
pygame
PyOpenGL
PyOpenGL-accelerate
numpy

# 新增依赖 (如果mocap_api.py需要)
docutils
```

================================================================================
                         九、附录
================================================================================

A.1 MocapAPI核心类速查表
--------------------------------------------------------------------------------

【MCPApplication】 - 应用管理
  - open() -> (bool, str)      # 打开连接
  - close() -> (bool, str)     # 关闭连接
  - poll_next_event() -> list  # 轮询事件
  - queue_command(cmd) -> void # 发送命令
  - get_avatars() -> list      # 获取所有Avatar

【MCPSettings】 - 连接配置
  - set_bvh_data(type)         # 设置数据格式
  - set_bvh_rotation(order)    # 设置旋转顺序
  - SetSettingsUDPEx(ip, port) # 设置本机UDP
  - SetSettingsUDPServer(ip, port) # 设置设备UDP

【MCPAvatar】 - 角色数据
  - get_name() -> str          # 获取名称
  - get_joints() -> list       # 获取所有关节
  - get_root_joint() -> MCPJoint # 获取根关节

【MCPJoint】 - 关节数据
  - get_name() -> str          # 获取关节名
  - get_local_position() -> (x,y,z)    # 获取位置
  - get_local_rotation() -> (w,x,y,z)  # 获取旋转(四元数)
  - get_children() -> list     # 获取子关节

【EMCPCommand】 - 命令枚举
  - CommandStartCapture = 0    # 开始采集
  - CommandStopCapture = 1     # 停止采集
  - CommandZeroPosition = 2    # 零位置
  - CommandCalibrateMotion = 3 # 校准
  - CommandStartRecored = 4    # 开始录制
  - CommandStopRecored = 5     # 停止录制

【MCPEventType】 - 事件类型
  - AvatarUpdated = 256        # Avatar数据更新
  - RigidBodyUpdated = 512     # 刚体更新
  - Error = 768                # 错误
  - CommandReply = 1536        # 命令响应

A.2 关节父子关系参考
--------------------------------------------------------------------------------

Hips (根)
├── RightUpLeg
│   └── RightLeg
│       └── RightFoot
├── LeftUpLeg
│   └── LeftLeg
│       └── LeftFoot
└── Spine
    └── Spine1
        └── Spine2
            ├── Neck
            │   └── Neck1
            │       └── Head
            ├── RightShoulder
            │   └── RightArm
            │       └── RightForeArm
            │           └── RightHand
            │               ├── RightHandThumb1-3
            │               ├── RightInHandIndex -> RightHandIndex1-3
            │               ├── RightInHandMiddle -> RightHandMiddle1-3
            │               ├── RightInHandRing -> RightHandRing1-3
            │               └── RightInHandPinky -> RightHandPinky1-3
            └── LeftShoulder
                └── LeftArm
                    └── LeftForeArm
                        └── LeftHand
                            ├── LeftHandThumb1-3
                            ├── LeftInHandIndex -> LeftHandIndex1-3
                            ├── LeftInHandMiddle -> LeftHandMiddle1-3
                            ├── LeftInHandRing -> LeftHandRing1-3
                            └── LeftInHandPinky -> LeftHandPinky1-3

A.3 常见问题与解决方案
--------------------------------------------------------------------------------

Q1: 连接设备失败
A1: 检查以下项目:
    - 本机IP是否配置为10.42.0.x网段
    - PN-Link设备是否已开机并处于直连模式
    - 防火墙是否阻止了UDP端口

Q2: 没有接收到数据
A2: 确保:
    - 已发送CommandStartCapture命令
    - 正在轮询poll_next_event
    - 检查事件类型是否为AvatarUpdated

Q3: 骨骼姿态不正确
A3: 可能原因:
    - 四元数转换顺序错误（确认使用(w,x,y,z)顺序）
    - 坐标系不匹配（MocapAPI使用Y轴向上）
    - 单位不一致（MocapAPI使用厘米）

Q4: 导出的BVH无法正确加载
A4: 检查:
    - 通道数量与层级结构是否匹配
    - 欧拉角转换是否使用正确的旋转顺序
    - Frame Time值是否正确

================================================================================
                              文档结束
================================================================================
